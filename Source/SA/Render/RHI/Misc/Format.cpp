// Copyright (c) 2023 Sapphire's Suite. All Rights Reserved.

#include <Misc/Format.hpp>

namespace SA::RND
{
#if SA_RENDER_LOWLEVEL_VULKAN_IMPL

	namespace VK
	{
		static const VkFormat vkFormatIndexMap[] = {
			VK_FORMAT_UNDEFINED,

			VK_FORMAT_R8_UNORM,
			VK_FORMAT_R8_SNORM,
			VK_FORMAT_R8_UINT,
			VK_FORMAT_R8_SINT,

			VK_FORMAT_R8G8_UNORM,
			VK_FORMAT_R8G8_SNORM,
			VK_FORMAT_R8G8_UINT,
			VK_FORMAT_R8G8_SINT,

			VK_FORMAT_R8G8B8A8_UNORM,
			VK_FORMAT_R8G8B8A8_SNORM,
			VK_FORMAT_R8G8B8A8_UINT,
			VK_FORMAT_R8G8B8A8_SINT,
			VK_FORMAT_R8G8B8A8_SRGB,

			VK_FORMAT_B8G8R8A8_UNORM,
			VK_FORMAT_B8G8R8A8_SNORM,
			VK_FORMAT_B8G8R8A8_UINT,
			VK_FORMAT_B8G8R8A8_SINT,
			VK_FORMAT_B8G8R8A8_SRGB,

			VK_FORMAT_R16_UNORM,
			VK_FORMAT_R16_SNORM,
			VK_FORMAT_R16_UINT,
			VK_FORMAT_R16_SINT,
			VK_FORMAT_R16_SFLOAT,

			VK_FORMAT_R16G16_UNORM,
			VK_FORMAT_R16G16_SNORM,
			VK_FORMAT_R16G16_UINT,
			VK_FORMAT_R16G16_SINT,
			VK_FORMAT_R16G16_SFLOAT,

			VK_FORMAT_R16G16B16A16_UNORM,
			VK_FORMAT_R16G16B16A16_SNORM,
			VK_FORMAT_R16G16B16A16_UINT,
			VK_FORMAT_R16G16B16A16_SINT,
			VK_FORMAT_R16G16B16A16_SFLOAT,

			VK_FORMAT_R32_UINT,
			VK_FORMAT_R32_SINT,
			VK_FORMAT_R32_SFLOAT,

			VK_FORMAT_R32G32_UINT,
			VK_FORMAT_R32G32_SINT,
			VK_FORMAT_R32G32_SFLOAT,

			VK_FORMAT_R32G32B32_UINT,
			VK_FORMAT_R32G32B32_SINT,
			VK_FORMAT_R32G32B32_SFLOAT,

			VK_FORMAT_R32G32B32A32_UINT,
			VK_FORMAT_R32G32B32A32_SINT,
			VK_FORMAT_R32G32B32A32_SFLOAT,

			VK_FORMAT_D16_UNORM,
			VK_FORMAT_D32_SFLOAT,
			VK_FORMAT_D24_UNORM_S8_UINT,
		};

		VkFormat API_GetFormat(RHI::Format _vkFormat)
		{
			const uint32_t index = static_cast<uint32_t>(_vkFormat);

			SA_ASSERT((OutOfRange, index, 0u, sizeof(vkFormatIndexMap)), SA.Render.RHI.Vulkan,
				(L"Format value [%1] invalid", index));

			return vkFormatIndexMap[index];
		}

		RHI::Format API_GetFormat(VkFormat _vkFormat)
		{
			for(uint32_t i = 0; i < sizeof(vkFormatIndexMap); ++i)
			{
				if(vkFormatIndexMap[i] == _vkFormat)
					return static_cast<RHI::Format>(i);
			}

			SA_LOG((L"VkFormat [%1] not supported yet!", static_cast<uint32_t>(_vkFormat)), Error, Sa.Render.RHI.Vulkan);

			return RHI::Format::R8G8B8A8_UNORM;
		}
	}

#endif


#if SA_RENDER_LOWLEVEL_DX12_IMPL

	namespace DX12
	{
		static const DXGI_FORMAT d12FormatIndexMap[] = {
			DXGI_FORMAT_UNKNOWN,

			DXGI_FORMAT_R8_UNORM,
			DXGI_FORMAT_R8_SNORM,
			DXGI_FORMAT_R8_UINT,
			DXGI_FORMAT_R8_SINT,

			DXGI_FORMAT_R8G8_UNORM,
			DXGI_FORMAT_R8G8_SNORM,
			DXGI_FORMAT_R8G8_UINT,
			DXGI_FORMAT_R8G8_SINT,

			DXGI_FORMAT_R8G8B8A8_UNORM,
			DXGI_FORMAT_R8G8B8A8_SNORM,
			DXGI_FORMAT_R8G8B8A8_UINT,
			DXGI_FORMAT_R8G8B8A8_SINT,
			DXGI_FORMAT_R8G8B8A8_UNORM_SRGB,

			DXGI_FORMAT_B8G8R8A8_UNORM,
			DXGI_FORMAT_B8G8R8A8_TYPELESS,
			DXGI_FORMAT_B8G8R8A8_TYPELESS,
			DXGI_FORMAT_B8G8R8A8_TYPELESS,
			DXGI_FORMAT_B8G8R8A8_UNORM_SRGB,

			DXGI_FORMAT_R16_UNORM,
			DXGI_FORMAT_R16_SNORM,
			DXGI_FORMAT_R16_UINT,
			DXGI_FORMAT_R16_SINT,
			DXGI_FORMAT_R16_FLOAT,

			DXGI_FORMAT_R16G16_UNORM,
			DXGI_FORMAT_R16G16_SNORM,
			DXGI_FORMAT_R16G16_UINT,
			DXGI_FORMAT_R16G16_SINT,
			DXGI_FORMAT_R16G16_FLOAT,

			DXGI_FORMAT_R16G16B16A16_UNORM,
			DXGI_FORMAT_R16G16B16A16_SNORM,
			DXGI_FORMAT_R16G16B16A16_UINT,
			DXGI_FORMAT_R16G16B16A16_SINT,
			DXGI_FORMAT_R16G16B16A16_FLOAT,

			DXGI_FORMAT_R32_UINT,
			DXGI_FORMAT_R32_SINT,
			DXGI_FORMAT_R32_FLOAT,

			DXGI_FORMAT_R32G32_UINT,
			DXGI_FORMAT_R32G32_SINT,
			DXGI_FORMAT_R32G32_FLOAT,

			DXGI_FORMAT_R32G32B32_UINT,
			DXGI_FORMAT_R32G32B32_SINT,
			DXGI_FORMAT_R32G32B32_FLOAT,

			DXGI_FORMAT_R32G32B32A32_UINT,
			DXGI_FORMAT_R32G32B32A32_SINT,
			DXGI_FORMAT_R32G32B32A32_FLOAT,

			DXGI_FORMAT_D16_UNORM,
			DXGI_FORMAT_D32_FLOAT,
			DXGI_FORMAT_D24_UNORM_S8_UINT,
		};

		DXGI_FORMAT API_GetFormat(RHI::Format _rhiFormat)
		{
			const uint32_t index = static_cast<uint32_t>(_rhiFormat);

			SA_ASSERT((OutOfRange, index, 0u, sizeof(d12FormatIndexMap)), SA.Render.RHI.DX12,
				(L"Format value [%1] invalid", index));

			return d12FormatIndexMap[index];
		}
		
		RHI::Format API_GetFormat(DXGI_FORMAT _d12Format)
		{
			for (uint32_t i = 0; i < sizeof(d12FormatIndexMap); ++i)
			{
				if (d12FormatIndexMap[i] == _d12Format)
					return static_cast<RHI::Format>(i);
			}

			SA_LOG((L"DXGI_FORMAT [%1] not supported yet!", static_cast<uint32_t>(_d12Format)), Error, Sa.Render.RHI.DX12);

			return RHI::Format::R8G8B8A8_UNORM;
		}
	}

#endif
}
